--LAB 12-14 Oct 
--Setting up database 
	--1 Restore [stock_market] database from back up file
/*
What Is a Stock Symbol (Ticker)?
Her hisse icin verilen unik kod, firma givenligi icin onemli

A stock symbol is a unique series of letters assigned to a 
security for trading purposes. Stocks listed on the 
New York Stock Exchange (NYSE) can have four or fewer letters. 
Nasdaq-listed securities can have up to five characters. 
Symbols are just a shorthand way of describing a company's stock, 
so there is no significant difference between those that have three letters 
and those that have four or five. Stock symbols are also known as ticker symbols.
*/
	
--1: How to find the close price from one day compared to the close price of the next day.

SELECT TickerSymbol, TradeDate, ClosePrice 
FROM dbo.StockHistory
ORDER BY TickerSymbol, TradeDate;

SELECT TickerSymbol, TradeDate, ClosePrice
	,Lag(ClosePrice) OVER(PARTITION BY TickerSymbol ORDER BY TradeDate) AS [Prev Close Price]
	,ClosePrice - 
	 Lag(ClosePrice) OVER(PARTITION BY TickerSymbol ORDER BY TradeDate) AS [Lag Change]
	,Lead(ClosePrice) OVER(PARTITION BY TickerSymbol ORDER BY TradeDate) AS [Next Close Price]
	,Lead(ClosePrice) OVER(PARTITION BY TickerSymbol ORDER BY TradeDate)-ClosePrice AS [Lead Change]
FROM dbo.StockHistory
ORDER BY TickerSymbol, TradeDate;

--Which Windows function can be used for this problem?
--LEAD()/LAG()  Functions
--LEAD() – peek forward a number of rows
--LAG() – look back a number of rows
--Have access to that row's data
--Based off of current row!

--use a Lag() function to access previous rows data as per defined offset value.
SELECT TickerSymbol, TradeDate, ClosePrice,
	ClosePrice - 
	LAG(ClosePrice) OVER(PARTITION BY TickerSymbol ORDER BY TradeDate) AS Dif
FROM dbo.StockHistory
ORDER BY TickerSymbol, TradeDate;

-- How to tune queries
-- TOOLS ==> Statistics IO,Execution Plans,Statistics Time
-- How compare the performance of two methods used to solve the stock market proble
-- Statistics

--Compare the performance of two methods used to solve the stock market problem. 

USE [stock_market]
GO
/*
SET STATISTICS IO and SET STATISTICS TIME are two settings that can help you measure the absolute resources needed by a server during query execution. 
SET STATISTICS IO displays statistics on the amount of disk activity generated by the query.
*/
SET STATISTICS IO ON 
GO
--query 1:using LAG() function

-----------------------------------------------------------------
--query2: using outer apply query
--OUTER APPLY operator returns all the rows from the 
--left table expression irrespective of its match 
--with the right table expression. 
--For those rows for which there are no corresponding matches in
--the right table expression, it contains NULL 
--values in columns of the right table expression.
/*
OUTER APPLY returns both rows that produce a result set, and rows that do not, 
with NULL values in the columns produced by the table-valued function. 
OUTER APPLY work as LEFT OUTER JOIN. Above both query produce same result.
*/

SELECT O.TickerSymbol, O.TradeDate, O.ClosePrice, 
	O.ClosePrice - CA.ClosePrice AS Change
FROM dbo.StockHistory AS O 
OUTER APPLY (
--select top one to make sure that to get just one row for each outer row
	SELECT TOP(1) I.ClosePrice 
	FROM dbo.StockHistory AS I 
	WHERE I.TickerSymbol = O.TickerSymbol
--inner query filtering on the ticker symbol and the trade date of the outer query, 
--making sure that the inner query trade date is less than the outer query trade date
		AND I.TradeDate < O.TradeDate
	ORDER BY I.TradeDate) AS CA
ORDER BY O.TickerSymbol, O.TradeDate;
--------------------------------------------------------------------
/*

(695304 rows affected)
Table 'stockhistory'. Scan count 1, logical reads 2597, physical reads 821, page server reads 0, read-ahead reads 2612, page server read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob page server reads 0, lob read-ahead reads 0, lob page server read-ahead reads 0.
Table 'Worktable'. Scan count 0, logical reads 0, physical reads 0, page server reads 0, read-ahead reads 0, page server read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob page server reads 0, lob read-ahead reads 0, lob page server read-ahead reads 0.

(695304 rows affected)
Table 'stockhistory'. Scan count 695305, logical reads 2225168, physical reads 1, 
page server reads 0, read-ahead reads 510, page server read-ahead reads 0, lob logical reads 0, lob physical reads 0, lob page server reads 0, 
lob read-ahead reads 0, lob page server read-ahead reads 0.
*/
SET STATISTICS IO OFF;
GO
SET STATISTICS TIME ON;
Go

CREATE TABLE #Stock1(TickerSymbol VARCHAR(4), TradeDate DATE, ClosePrice MONEY, Change MONEY);
CREATE TABLE #Stock2(TickerSymbol VARCHAR(4), TradeDate DATE, ClosePrice MONEY, Change MONEY);


INSERT INTO #Stock1(TickerSymbol, TradeDate, ClosePrice, Change)
SELECT TickerSymbol, TradeDate, ClosePrice,
	ClosePrice - 
	LAG(ClosePrice) OVER(PARTITION BY TickerSymbol ORDER BY TradeDate) AS Change
FROM dbo.StockHistory;

INSERT INTO #Stock2(TickerSymbol, TradeDate, ClosePrice, Change)
SELECT O.TickerSymbol, O.TradeDate, O.ClosePrice, 
	O.ClosePrice - CA.ClosePrice AS Change
FROM dbo.StockHistory AS O 
OUTER APPLY (
	SELECT TOP(1) I.ClosePrice 
	FROM dbo.StockHistory AS I 
	WHERE I.TickerSymbol = O.TickerSymbol 
		AND I.TradeDate < O.TradeDate
	ORDER BY I.TradeDate) AS CA;

-----------------End of LAB-1 12 OCTOBER---------------------
SET STATISTICS IO OFF;
GO
SET STATISTICS TIME OFF;
GO

--Turn on Actual Execution Plan
SELECT TickerSymbol, TradeDate, ClosePrice,
	ClosePrice - 
	LAG(ClosePrice) OVER(PARTITION BY TickerSymbol ORDER BY TradeDate) AS Dif
FROM dbo.StockHistory
ORDER BY TickerSymbol, TradeDate;


SELECT O.TickerSymbol, O.TradeDate, O.ClosePrice, 
	O.ClosePrice - CA.ClosePrice AS Change
FROM dbo.StockHistory AS O 
OUTER APPLY (
	SELECT TOP(1) I.ClosePrice 
	FROM dbo.StockHistory AS I 
	WHERE I.TickerSymbol = O.TickerSymbol 
		AND I.TradeDate < O.TradeDate
	ORDER BY I.TradeDate) AS CA
ORDER BY O.TickerSymbol, O.TradeDate;

--found customers who has placed more than one order on the same day.
use  [AdventureWorks2017]
go
select t1.[CustomerID],t1.[SalesOrderID],t1.[OrderDate],
       ROW_NUMBER() over (partition by t1.[OrderDate],t1.[CustomerID] order by t1.[SalesOrderID]) [row number]
from [Sales].[SalesOrderHeader] t1

--inner join [Sales].[SalesOrderHeader] t2
--on t1.[OrderDate]=t2.OrderDate
--where t1.[SalesOrderID]<t2.[SalesOrderID]

--RANKING Functions in a different way

--------------------------------------------------
--Compare ROW_NUMBER, RANK, and DENSE_RANK
SELECT SOD.ProductID, SOH.SalesOrderID, 
	FORMAT(SOH.OrderDate, 'yyyy-MM-dd') AS OrderDate, 
	ROW_NUMBER()	OVER(PARTITION BY SOD.ProductID ORDER BY SOH.SalesOrderID) AS [Row Number],
	RANK()			OVER(PARTITION BY SOD.ProductID ORDER BY SOH.SalesOrderID) AS [Rank],
	DENSE_RANK()	OVER(PARTITION BY SOD.ProductID ORDER BY SOH.SalesOrderID) AS [Dense Rank]
FROM Sales.SalesOrderHeader SOH 
JOIN Sales.SalesOrderDetail SOD on SOH.SalesOrderID = SOD.SalesOrderID
WHERE SOD.ProductID BETWEEN 710 AND 720
ORDER BY SOD.ProductID, SOH.SalesOrderID;

--The reason the functions return the same values, is that the order 
--by column is unique, there are no ties.

--Non-unique ORDER BY
SELECT SOD.ProductID, SOH.SalesOrderID, 
	FORMAT(SOH.OrderDate, 'yyyy-MM-dd') AS OrderDate, 
	ROW_NUMBER()	OVER(PARTITION BY SOD.ProductID ORDER BY SOH.OrderDate) AS [Row Number],
	RANK()			OVER(PARTITION BY SOD.ProductID ORDER BY SOH.OrderDate) AS [Rank], --order date is not uniqe
	DENSE_RANK()	OVER(PARTITION BY SOD.ProductID ORDER BY SOH.OrderDate) AS [Dense Rank]
FROM Sales.SalesOrderHeader SOH 
JOIN Sales.SalesOrderDetail SOD on SOH.SalesOrderID = SOD.SalesOrderID
WHERE SOD.ProductID BETWEEN 710 AND 720
ORDER BY SOD.ProductID, SOH.OrderDate;

/*NTILE Function 
is different than the others, in that it's not returning 
incrementing values, it returns a value that divides the rows into buckets. 
To make things simple to understand, I've added a query to a CTE. 
The query returns the count of sales grouped by product ID. In the outer query, I've added NTILE. 
I've supplied an argument of 10 to NTILE, meaning that I want 10 buckets returned. 
The order by clause is order count. When I run the query, the products with the lowest count of orders, 
end up in bucket one. The next set ends up in bucket two, and so on. 
There are 266 products returned. That's not evenly-divisible by 10. 
Most of the buckets have 26 products, but the first six buckets each have 27 products.
*/
-- Make up 10 groups number of ordered prodcuts, 
-- like group  1: the products with the lowest  count of orders
--      group 10: the products with the highest count of orders
--NTILE :returns a value that divides the rows into buckets
--lowest total sales in bucket 1...
WITH Sales AS 
(
	SELECT SOD.ProductID, COUNT(*) AS OrderCount
	FROM Sales.SalesOrderHeader SOH 
	JOIN Sales.SalesOrderDetail SOD on SOH.SalesOrderID = SOD.SalesOrderID
	GROUP BY SOD.ProductID
)
SELECT ProductID, OrderCount,
	NTILE(10) OVER(ORDER BY OrderCount) AS Bucket
FROM Sales;
/*
the ranking functions are just a step along the way to the solution, 
not the solution in itself. In order to show you that they are 
actually useful, let's take a look at some real-world query problems 
that can be solved with the ranking functions.

1- the islands problem:
data with a series of numbers or dates
use database [stock_market]
*/
use  [stock_market]
--Look for Islands in ID
SELECT ID FROM Islands;

--Step 1: add a row_number() to find out certain pattern in the data
SELECT ID, ROW_NUMBER() OVER(ORDER BY ID) AS RowNum
FROM Islands;

--Step 2: find the difference between row id and id
SELECT ID, ROW_NUMBER() OVER(ORDER BY ID) AS RowNum,
	ID - ROW_NUMBER() OVER(ORDER BY ID) AS Diff
FROM Islands;

--Step 3: Group by Diff
WITH Diffs AS (
	SELECT ID, ROW_NUMBER() OVER(ORDER BY ID) AS RowNum,
		ID - ROW_NUMBER() OVER(ORDER BY ID) AS Diff
	FROM Islands)
SELECT MIN(ID) AS BeginningOfIsland,
	MAX(ID) AS EndOfIsland
FROM Diffs 
GROUP BY Diff;

--Find the islands in Dates
SELECT OrderDate 
FROM Islands
ORDER BY OrderDate;

--Step 1: Add row_number
SELECT OrderDate, ROW_NUMBER() OVER(ORDER BY OrderDate) AS RowNum
FROM Islands;

--Try RANK
SELECT OrderDate, RANK() OVER(ORDER BY OrderDate) AS Rnk
FROM Islands;

--Try DENSE_RANK
SELECT OrderDate, 
	DENSE_RANK() OVER(ORDER BY OrderDate) AS DenseRnk
FROM Islands;

--Step 2: Add to a base date
WITH Level1 AS (
	SELECT OrderDate, 
		DENSE_RANK() OVER(ORDER BY OrderDate) AS DenseRnk
	FROM Islands)
SELECT OrderDate, 
	DATEADD(d,DenseRnk,'2014-12-31') AS NewDate
FROM Level1;

--Step 3: Find the difference
WITH Level1 AS (
	SELECT OrderDate, 
		DENSE_RANK() OVER(ORDER BY OrderDate) AS DenseRnk
	FROM Islands),
Level2 AS (
	SELECT OrderDate, 
		DATEADD(d,DenseRnk,'2014-12-31') AS NewDate
	FROM Level1)
SELECT OrderDate, 
	DATEDIFF(d, NewDate, OrderDate) DIFF
FROM Level2;

--Step 4: Group by the difference
WITH Level1 AS (
	SELECT OrderDate, 
		DENSE_RANK() OVER(ORDER BY OrderDate) AS DenseRnk
	FROM Islands),
Level2 AS (
	SELECT OrderDate, 
		DATEADD(d,DenseRnk,'2014-12-31') AS NewDate
	FROM Level1),
Level3 AS (
	SELECT OrderDate, 
		DATEDIFF(d, NewDate, OrderDate) DIFF
	FROM Level2)
SELECT MIN(OrderDate) AS IslandStart, 
	MAX(OrderDate) AS IslandEnd
FROM Level3 
GROUP BY DIFF;

WITH Dates AS (
	SELECT OrderDate, 
		DATEDIFF(d,DATEADD(d, DENSE_RANK() OVER(ORDER BY OrderDate),
			'2014-12-31'),OrderDate) AS DIFF
	FROM Islands)
SELECT MIN(OrderDate) AS IslandStart, MAX(OrderDate) AS IslandEnd
FROM Dates 
GROUP BY DIFF;

--Deduplication
/*
To recreate the table if needed:
exec usp_CreateDuplicates;
*/
SELECT ID, Val1, Val2
FROM Duplicates;

--Step 1: Add a row_number
SELECT ID, Val1, Val2, 
	ROW_NUMBER() OVER(ORDER BY ID) AS RowNum
FROM Duplicates;

--Step 2: Partition by each column
SELECT ID, Val1, Val2, 
	ROW_NUMBER() 
	OVER(PARTITION BY ID, Val1, Val2 ORDER BY ID) AS RowNum
FROM Duplicates;

SELECT ID, Val1, Val2, 
	ROW_NUMBER() 
	OVER(PARTITION BY ID, Val1, Val2 ORDER BY ID) AS RowNum
FROM Duplicates
WHERE ROW_NUMBER() OVER(PARTITION BY ID, Val1, Val2 ORDER BY ID) <> 1;

--Step 3: Separate the logic and filter
WITH Dupes AS (
	SELECT ID, Val1, Val2, 
		ROW_NUMBER() 
		OVER(PARTITION BY ID, Val1, Val2 ORDER BY ID) AS RowNum
	FROM Duplicates)
SELECT ID, Val1, Val2, RowNum 
FROM Dupes 
WHERE RowNum <> 1;

--Step 4: Delete
WITH Dupes AS (
	SELECT ID, Val1, Val2, 
		ROW_NUMBER() 
		OVER(PARTITION BY ID, Val1, Val2 ORDER BY ID) AS RowNum
	FROM Duplicates)
DELETE Dupes 
WHERE RowNum <> 1;

--View the results
SELECT ID, Val1, Val2 
FROM Duplicates
ORDER BY ID;

--First N
USE AdventureWorks2014;
GO
--This is the top n problem. In this case to find the first four 
--orders for each product, for a particular year.
--What are the first four orders for each product?
SELECT SOD.ProductID, SOH.SalesOrderID, 
	FORMAT(SOH.OrderDate,'yyyy-MM-dd') AS OrderDate
FROM Sales.SalesOrderHeader AS SOH 
JOIN Sales.SalesOrderDetail AS SOD ON SOH.SalesOrderID = SOD.SalesOrderID
WHERE SOH.OrderDate >= '2011-01-01' AND SOH.OrderDate < '2012-01-01';

--TOP(4) ?
SELECT TOP(4) SOD.ProductID, SOH.SalesOrderID, 
	FORMAT(SOH.OrderDate,'yyyy-MM-dd') AS OrderDate
FROM Sales.SalesOrderHeader AS SOH 
JOIN Sales.SalesOrderDetail AS SOD ON SOH.SalesOrderID = SOD.SalesOrderID
WHERE SOH.OrderDate >= '2011-01-01' AND SOH.OrderDate < '2012-01-01';

--Step 1: Add a ROW_NUMBER
SELECT SOD.ProductID, SOH.SalesOrderID, 
	FORMAT(SOH.OrderDate,'yyyy-MM-dd') AS OrderDate,
	ROW_NUMBER() OVER(PARTITION BY SOD.ProductID ORDER BY SOH.SalesOrderID) AS RowNum
FROM Sales.SalesOrderHeader AS SOH 
JOIN Sales.SalesOrderDetail AS SOD ON SOH.SalesOrderID = SOD.SalesOrderID
WHERE SOH.OrderDate >= '2011-01-01' AND SOH.OrderDate < '2012-01-01';

--Step 2: Separate the logic
WITH Orders AS (
	SELECT SOD.ProductID, SOH.SalesOrderID, 
		FORMAT(SOH.OrderDate,'yyyy-MM-dd') AS OrderDate,
		ROW_NUMBER() OVER(PARTITION BY SOD.ProductID ORDER BY SOH.SalesOrderID) AS RowNum
	FROM Sales.SalesOrderHeader AS SOH 
	JOIN Sales.SalesOrderDetail AS SOD ON SOH.SalesOrderID = SOD.SalesOrderID
	WHERE SOH.OrderDate >= '2011-01-01' AND SOH.OrderDate < '2012-01-01')
SELECT ProductID, SalesOrderID, OrderDate 
FROM Orders 
WHERE RowNum <= 4;

--The Gold Star Customers
USE AdventureWorks2017;
GO

--Step 1: Write aggregate query
SELECT SUM(TotalDue) AS TotalSales, 
	CustomerID
FROM Sales.SalesOrderHeader
WHERE OrderDate >= '2014-01-01' AND 
	OrderDate < '2015-01-01'
GROUP BY CustomerID;

--Step 2: Move Query to CTE and add NTILE
WITH Sales AS (
	SELECT SUM(TotalDue) AS TotalSales, 
	CustomerID
	FROM Sales.SalesOrderHeader
	WHERE OrderDate >= '2014-01-01' AND 
		OrderDate < '2015-01-01'
	GROUP BY CustomerID)
SELECT TotalSales, CustomerID, 
	NTILE(4) OVER(ORDER BY TotalSales) AS Bucket
FROM Sales;

--Step 3: Add Gold Star logic
WITH Sales AS (
	SELECT SUM(TotalDue) AS TotalSales, 
	CustomerID
	FROM Sales.SalesOrderHeader
	WHERE OrderDate >= '2014-01-01' AND 
		OrderDate < '2015-01-01'
	GROUP BY CustomerID), 
Buckets AS (
	SELECT TotalSales, CustomerID, 
		NTILE(4) OVER(ORDER BY TotalSales) AS Bucket
	FROM Sales)
SELECT TotalSales, CustomerID,
	CHOOSE(Bucket,'No star','Bronze Star',
		'Silver Star','Gold Star') AS CustomerCategory
FROM Buckets;

--second way with case statement
SELECT SUM(TotalDue) AS TotalSales, CustomerID, 
	CHOOSE(NTILE(4) OVER(ORDER BY SUM(TotalDue)),
	'No star','Bronze Star','Silver Star','Gold Star') 
	AS CustomerCategory
FROM Sales.SalesOrderHeader
WHERE OrderDate >= '2014-01-01' AND 
	OrderDate < '2015-01-01'
GROUP BY CustomerID;
---------------------------------------
/*
T-SQL Window Functions Class
Aggregate Functions
*/
USE AdventureWorks2014;
GO

SELECT ProductID, name, FinishedGoodsFlag
FROM Production.Product;

--Need a list of products and average list price
SELECT ProductID, name, ListPrice,
	COUNT(*)  CountOfProduct, 
	AVG(ListPrice) AS AvgListPrice
FROM Production.Product 
WHERE FinishedGoodsFlag = 1;

--Add a group by
SELECT ProductID, name, ListPrice,
	COUNT(*)  CountOfProduct,
	AVG(ListPrice) AS AvgListPrice
FROM Production.Product
WHERE FinishedGoodsFlag = 1
GROUP BY ProductID, name, ListPrice;

--Add OVER clause instead
SELECT ProductID, name, ListPrice,
	COUNT(*) OVER() CountOfProduct,
	AVG(ListPrice) OVER() AS AvgListPrice
FROM Production.Product
WHERE FinishedGoodsFlag = 1;

--Need subtotals by category
--Join to get categories
SELECT P.ProductID, P.name AS ProductName, 
	C.Name AS CategoryName, ListPrice,
	COUNT(*) OVER() CountOfProduct,
	AVG(ListPrice) OVER() AS AvgListPrice
FROM Production.Product AS P
JOIN Production.ProductSubcategory AS S 
	ON S.ProductSubcategoryID = P.ProductSubcategoryID
JOIN Production.ProductCategory AS C 
	ON C.ProductCategoryID = S.ProductCategoryID
WHERE FinishedGoodsFlag = 1;



--Partition by ProductCategoryID
SELECT P.ProductID, P.name AS ProductName, 
	C.Name AS CategoryName, ListPrice,
	COUNT(*) OVER(PARTITION BY C.ProductCategoryID) CountOfProduct,
	AVG(ListPrice) OVER(PARTITION BY C.ProductCategoryID) AS AvgListPrice
FROM Production.Product AS P
JOIN Production.ProductSubcategory AS S 
	ON S.ProductSubcategoryID = P.ProductSubcategoryID
JOIN Production.ProductCategory AS C 
	ON C.ProductCategoryID = S.ProductCategoryID
WHERE FinishedGoodsFlag = 1;


--Mix windows
SELECT P.ProductID, P.name AS ProductName, 
	C.Name AS CategoryName, ListPrice,
	COUNT(*) OVER(PARTITION BY C.ProductCategoryID) CountOfProduct,
	AVG(ListPrice) OVER(PARTITION BY C.ProductCategoryID) AS AvgListPrice,
	MIN(ListPrice) OVER() AS MinListPrice,
	MAX(ListPrice) OVER() AS MaxListPrice
FROM Production.Product AS P
JOIN Production.ProductSubcategory AS S 
	ON S.ProductSubcategoryID = P.ProductSubcategoryID
JOIN Production.ProductCategory AS C 
	ON C.ProductCategoryID = S.ProductCategoryID
WHERE FinishedGoodsFlag = 1;

--Real world example: get a percent of sales for each type of bike for a particular year
/*
We need to compare the sales of each bike category to the overall bike sales. 
There are several traditional techniques that can be used to solve those but 
they all involve calculating the total sales separately. 
Here is one way. I've written a CTE. In the CTE, I have the same tables 
and WHERE clause that I have before. The difference is that 
I am not grouping on the type of bicycle and I'm just calculating the sales.
*/

SELECT S.Name AS BikeSubCategory, 
		SUM(LineTotal) AS BikeSales
FROM Sales.SalesOrderDetail AS SOD 
JOIN Sales.SalesOrderHeader AS SOH 
	ON SOD.SalesOrderID = SOH.SalesOrderID
JOIN Production.Product AS P 
	ON P.ProductID = SOD.ProductID
JOIN Production.ProductSubcategory AS S 
	ON S.ProductSubcategoryID = P.ProductSubcategoryID	
WHERE S.Name LIKE '%Bikes%' 
	AND SOH.OrderDate >= '2014-01-01' 
	AND SOH.OrderDate < '2015-01-01'
GROUP BY S.Name;


--One traditional way to solve
--Query without window aggregate
WITH GrandTotal AS (
	SELECT SUM(LineTotal) AS TotalSales
	FROM Sales.SalesOrderDetail AS SOD 
	JOIN Sales.SalesOrderHeader AS SOH 
		ON SOD.SalesOrderID = SOH.SalesOrderID
	JOIN Production.Product AS P 
		ON P.ProductID = SOD.ProductID
	JOIN Production.ProductSubcategory AS S 
		ON S.ProductSubcategoryID = P.ProductSubcategoryID	
	WHERE S.Name LIKE '%Bikes%' 
		AND SOH.OrderDate >= '2014-01-01' 
		AND SOH.OrderDate < '2015-01-01')
SELECT S.Name AS BikeSubCategory, 
	SUM(LineTotal) AS BikeSales, 
	FORMAT(SUM(LineTotal) / TotalSales ,'P') AS PercentOfSales
FROM Sales.SalesOrderDetail AS SOD 
JOIN Sales.SalesOrderHeader AS SOH 
	ON SOD.SalesOrderID = SOH.SalesOrderID
JOIN Production.Product AS P 
	ON P.ProductID = SOD.ProductID
JOIN Production.ProductSubcategory AS S 
	ON S.ProductSubcategoryID = P.ProductSubcategoryID	
CROSS JOIN GrandTotal 
WHERE S.Name LIKE '%Bikes%' 
	AND SOH.OrderDate >= '2014-01-01' 
	AND SOH.OrderDate < '2015-01-01'
GROUP BY S.Name, TotalSales;

--Percent of sales for each type of bike
--Step 1
SELECT S.Name AS BikeSubCategory, 
		SUM(LineTotal) AS BikeSales
FROM Sales.SalesOrderDetail AS SOD 
JOIN Sales.SalesOrderHeader AS SOH 
	ON SOD.SalesOrderID = SOH.SalesOrderID
JOIN Production.Product AS P 
	ON P.ProductID = SOD.ProductID
JOIN Production.ProductSubcategory AS S 
	ON S.ProductSubcategoryID = P.ProductSubcategoryID	
WHERE S.Name LIKE '%Bikes%' 
	AND SOH.OrderDate >= '2014-01-01' 
	AND SOH.OrderDate < '2015-01-01'
GROUP BY S.Name;

--Step 2: CTE and add aggregate
WITH Sales AS (	
	SELECT S.Name AS BikeSubCategory, 
		 SUM(LineTotal) AS BikeSales
	FROM Sales.SalesOrderDetail AS SOD 
	JOIN Sales.SalesOrderHeader AS SOH 
		ON SOD.SalesOrderID = SOH.SalesOrderID
	JOIN Production.Product AS P 
		ON P.ProductID = SOD.ProductID
	JOIN Production.ProductSubcategory AS S 
		ON S.ProductSubcategoryID = P.ProductSubcategoryID	
	WHERE S.Name LIKE '%Bikes%' 
		AND SOH.OrderDate >= '2014-01-01' 
		AND SOH.OrderDate < '2015-01-01'
	GROUP BY S.Name )
SELECT BikeSubCategory, BikeSales,
	SUM(BikeSales) OVER() AS TotalSales
FROM Sales;


--Step 3: Division
WITH Sales AS (	
	SELECT S.Name AS BikeSubCategory, 
		 SUM(LineTotal) AS BikeSales
	FROM Sales.SalesOrderDetail AS SOD 
	JOIN Sales.SalesOrderHeader AS SOH 
		ON SOD.SalesOrderID = SOH.SalesOrderID
	JOIN Production.Product AS P 
		ON P.ProductID = SOD.ProductID
	JOIN Production.ProductSubcategory AS S 
		ON S.ProductSubcategoryID = P.ProductSubcategoryID	
	WHERE S.Name LIKE '%Bikes%' 
		AND SOH.OrderDate >= '2014-01-01' 
		AND SOH.OrderDate < '2015-01-01'
	GROUP BY S.Name )
SELECT BikeSubCategory, BikeSales, 
	SUM(BikeSales) OVER() AS TotalSales,
	FORMAT(BikeSales / SUM(BikeSales) OVER(),'P') AS PercentOfSales
FROM Sales;
------------------------
/*

Demo 3
*/

USE AdventureWorks2017; 
GO

--Typical aggregate query
SELECT CustomerID, SUM(TotalDue) AS CustomerSales
FROM Sales.SalesOrderHeader
WHERE OrderDate >= '2014-01-01' AND OrderDate < '2015-01-01'
GROUP BY CustomerID;

--Add a grand total
SELECT CustomerID, SUM(TotalDue) AS CustomerSales,
	SUM(TotalDue) OVER() AS TotalSales
FROM Sales.SalesOrderHeader
WHERE OrderDate >= '2014-01-01' AND OrderDate < '2015-01-01'
GROUP BY CustomerID;


--CTE first
WITH Totals AS (
	SELECT CustomerID, SUM(TotalDue) AS CustomerSales
	FROM Sales.SalesOrderHeader
	WHERE OrderDate >= '2014-01-01' AND OrderDate < '2015-01-01'
	GROUP BY CustomerID)
SELECT CustomerID, CustomerSales, 
	SUM(CustomerSales) OVER() TotalSales
FROM Totals;




--The window aggregate applies to the aggregate or a group by column
SELECT CustomerID, SUM(TotalDue) AS CustomerSales,
	SUM(SUM(TotalDue)) OVER() AS TotalSales
FROM Sales.SalesOrderHeader
WHERE OrderDate >= '2014-01-01' AND OrderDate < '2015-01-01'
GROUP BY CustomerID;




--Row number
SELECT CustomerID, SUM(TotalDue) AS CustomerSales,
	ROW_NUMBER() OVER(ORDER BY SUM(TotalDue)) AS RowNum
FROM Sales.SalesOrderHeader
WHERE OrderDate >= '2014-01-01' AND OrderDate < '2015-01-01'
GROUP BY CustomerID;


--DISTINCT

--Get a distinct list of customers and a count
--Here are the customers
SELECT DISTINCT CustomerID 
FROM Sales.SalesOrderHeader;


--Add Count
SELECT DISTINCT CustomerID, 
	COUNT(*) OVER() AS CountOfCustomers 
FROM Sales.SalesOrderHeader;

--Try adding distinct to count
SELECT DISTINCT CustomerID, 
	COUNT(DISTINCT CustomerID) OVER() AS CountOfCustomers 
FROM Sales.SalesOrderHeader;


--Solution 1: Find distinct list first
WITH Customers AS (
	SELECT DISTINCT CustomerID 
	FROM Sales.SalesOrderHeader)
SELECT CustomerID, COUNT(*) OVER() AS CountOfCustomers
FROM Customers;

--Solution 2: Use GROUP BY
SELECT CustomerID, 
	COUNT(*) OVER() AS CountOfCustomers
FROM Sales.SalesOrderHeader
GROUP BY CustomerID;
------------------------------------------------